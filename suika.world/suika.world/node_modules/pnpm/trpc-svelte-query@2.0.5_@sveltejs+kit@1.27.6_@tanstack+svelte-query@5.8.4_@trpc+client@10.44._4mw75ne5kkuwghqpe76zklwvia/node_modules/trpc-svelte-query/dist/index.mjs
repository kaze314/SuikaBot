import {
  callUtilMethod,
  splitUserOptions
} from "./chunk-53Y3YW5K.mjs";
import {
  getArrayQueryKey
} from "./chunk-E5VPA7AK.mjs";

// src/index.ts
export * from "@trpc/client";

// src/createTRPCSvelte.ts
import {
  QueryClient,
  createInfiniteQuery,
  createMutation,
  createQuery
} from "@tanstack/svelte-query";
import {
  createTRPCUntypedClient
} from "@trpc/client";
import {
  createFlatProxy,
  createRecursiveProxy
} from "@trpc/server/shared";
import { BROWSER } from "esm-env";
import { derived, readable } from "svelte/store";

// src/utils/isSvelteStore.ts
function isSvelteStore(obj) {
  return typeof obj === "object" && "subscribe" in obj && typeof obj.subscribe === "function";
}

// src/createTRPCSvelte.ts
var clientMethods = {
  query: [1, "query"],
  mutation: [0, "any"],
  infiniteQuery: [1, "infinite"]
};
function createSvelteInternalProxy(client, opts) {
  let queryClient;
  if (BROWSER) {
    queryClient = new QueryClient(opts.queryClientConfig);
  }
  return createFlatProxy((firstPath) => {
    switch (firstPath) {
      case "queryClient": {
        return queryClient;
      }
      case "hydrateFromServer": {
        return (data) => {
          let client2 = queryClient;
          if (!BROWSER) {
            client2 = new QueryClient(opts.queryClientConfig);
          }
          for (const [key, value] of data) {
            client2.setQueryData(key, value);
          }
          return client2;
        };
      }
    }
    return createRecursiveProxy(({ path, args: unknownArgs }) => {
      path.unshift(firstPath);
      const method = path.pop();
      const joinedPath = path.join(".");
      const methodData = clientMethods[method];
      if (!methodData) {
        const utils = path.pop();
        if (utils === "utils") {
          return callUtilMethod(
            client,
            queryClient,
            path,
            method,
            unknownArgs
          );
        }
        throw new TypeError(`trpc.${joinedPath}.${method} is not a function`);
      }
      const args = unknownArgs;
      const [optionIndex, queryType] = methodData;
      const options = args[optionIndex];
      const optionsStore = options && isSvelteStore(options) ? options : readable(options ?? {});
      const inputStore = (
        // Mutation doesn't have input
        method === "mutation" ? void 0 : (
          // If it's a store, use it
          args[0] && isSvelteStore(args[0]) ? args[0] : (
            // wrap the input in a store
            readable(args[0])
          )
        )
      );
      switch (method) {
        case "query": {
          const options2 = derived(
            [
              inputStore,
              optionsStore
            ],
            ([$input, $options]) => {
              const [queryOptions, trpcOptions] = splitUserOptions($options);
              const key = getArrayQueryKey(path, $input, queryType);
              return {
                ...queryOptions,
                enabled: queryOptions.enabled !== false && BROWSER,
                queryKey: key,
                queryFn: () => client.query(joinedPath, $input, trpcOptions)
              };
            }
          );
          return createQuery(options2);
        }
        case "mutation": {
          const options2 = derived(
            optionsStore,
            ($options) => {
              const [queryOptions, trpcOptions] = splitUserOptions($options);
              const key = getArrayQueryKey(path, void 0, queryType);
              return {
                ...queryOptions,
                mutationKey: key,
                mutationFn: (variables) => client.mutation(joinedPath, variables, trpcOptions)
              };
            }
          );
          return createMutation(options2);
        }
        case "infiniteQuery": {
          const options2 = derived(
            [
              inputStore,
              optionsStore
            ],
            ([$input, $options]) => {
              const [queryOptions, trpcOptions] = splitUserOptions($options);
              const key = getArrayQueryKey(path, $input, queryType);
              return {
                ...queryOptions,
                enabled: queryOptions.enabled !== false && BROWSER,
                queryKey: key,
                queryFn: (context) => {
                  const input = { ...$input, cursor: context.pageParam };
                  return client.query(joinedPath, input, trpcOptions);
                }
              };
            }
          );
          return createInfiniteQuery(options2);
        }
        default:
          throw new TypeError(`trpc.${joinedPath}.${method} is not a function`);
      }
    });
  });
}
function createTRPCSvelte(opts) {
  const client = createTRPCUntypedClient(opts);
  const proxy = createSvelteInternalProxy(client, opts);
  return proxy;
}
export {
  createTRPCSvelte
};
